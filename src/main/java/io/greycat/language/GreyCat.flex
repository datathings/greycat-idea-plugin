package io.greycat.language; // Package which will be the lexer generation location.

import com.intellij.psi.tree.IElementType;
import com.intellij.lexer.FlexLexer;

import static com.intellij.psi.TokenType.BAD_CHARACTER;
import static com.intellij.psi.TokenType.WHITE_SPACE;
import static io.greycat.language.psi.GreyCatTypes.*; // This is generated by the BNF
import static io.greycat.language.psi.GreyCatTypesExt.*; // This is a manual extension to handle "edge-cases"

import java.util.Stack;

%%
%{
  private static final class GreyCatLexerState {
    final int lCurlyCount;
    final int state;

    private GreyCatLexerState(int state, int lCurlyCount) {
      this.state = state;
      this.lCurlyCount = lCurlyCount;
    }

    @Override
    public String toString() {
      return "yystate = " + state + (lCurlyCount == 0 ? "" : "lCurlyCount = " + lCurlyCount);
    }
  }

  protected final Stack<GreyCatLexerState> stateStack = new Stack<>();
  protected int lCurlyCount;

  private void pushState(int state) {
    stateStack.push(new GreyCatLexerState(yystate(), lCurlyCount));
    lCurlyCount = 0;
    yybegin(state);
  }

  private void popState() {
    GreyCatLexerState state = stateStack.pop();
    lCurlyCount = state.lCurlyCount;
    yybegin(state.state);
  }

  GreyCatLexer() {
    this(null);
  }
%}

%public
%class GreyCatLexer
%implements FlexLexer
%function advance
%type IElementType
%eof{
  lCurlyCount = 0;
  stateStack.clear();
%eof}

%xstate IN_COMMENT IN_TEMPLATE IN_INTERPOLATION

IDENTIFIER=[a-zA-Z_][a-zA-Z0-9_]*
WHITE_SPACE=[ \t\n\x0B\f\r]+
BUILT_IN_TYPE = (i|f|u|i64|i32|i16|i8|u64|u32|u16|u8|f64|f32|f16|f8|time|duration|geo|us|ms|s|min|month|day|year|week|hour)
DIGIT = [0-9_]
EXPONENT = [Ee] [+-]? {DIGIT}+
NUMBER = {DIGIT}+ ("." {DIGIT}+)? _* {EXPONENT}? _* {BUILT_IN_TYPE}?
SINGLE_QUOTE = '
CHAR_LIT = {SINGLE_QUOTE}([^'\\]|\\.)*{SINGLE_QUOTE}

DOC_COMMENT = \/\/\/[^\n]*
LINE_COMMENT = \/\/[^\n]*

MULTI_LINE_COMMENT_START      = "/*"
MULTI_LINE_COMMENT_END        = "*/"

%%
// special state "changer"
<YYINITIAL, IN_INTERPOLATION> \"                          { pushState(IN_TEMPLATE); return DQUOTE; }

// next rules return temporary IElementType's that are replaced with MULTI_LINE_COMMENT
<YYINITIAL, IN_INTERPOLATION>  {MULTI_LINE_COMMENT_START} { pushState(IN_COMMENT); return MULTI_LINE_COMMENT_START; }

<IN_COMMENT>                   {MULTI_LINE_COMMENT_START} { pushState(IN_COMMENT); return MULTI_LINE_COMMENT_BODY; }
<IN_COMMENT>                   [^]                        {                        return MULTI_LINE_COMMENT_BODY; }
<IN_COMMENT>                   {MULTI_LINE_COMMENT_END}   { popState();            return yystate() == IN_COMMENT
                                                                                          ? MULTI_LINE_COMMENT_BODY // inner comment closed
                                                                                          : MULTI_LINE_COMMENT_END; }

<YYINITIAL>                    "{"                        { return LCURLY; }
<YYINITIAL>                    "}"                        { return RCURLY; }
<YYINITIAL>                    {DOC_COMMENT}              { return DOC_COMMENT; }

<IN_INTERPOLATION>             "{"                        { lCurlyCount++; return LCURLY; }
<IN_INTERPOLATION>             "}"                        {
                                                            if (lCurlyCount == 0) {
                                                              // we are supposed to get out of interpolation
                                                              popState();
                                                              return EXIT_INTERPOLATION;
                                                            }
                                                            lCurlyCount--;
                                                            return RCURLY;
                                                          }

// keywords
<YYINITIAL, IN_INTERPOLATION>  "abstract"                 { return ABSTRACT_KW; }
<YYINITIAL, IN_INTERPOLATION>  "as"                       { return AS_KW; }
<YYINITIAL, IN_INTERPOLATION>  "at"                       { return AT_KW; }
<YYINITIAL, IN_INTERPOLATION>  "break"                    { return BREAK_KW; }
<YYINITIAL, IN_INTERPOLATION>  "continue"                 { return CONTINUE_KW; }
<YYINITIAL, IN_INTERPOLATION>  "catch"                    { return CATCH_KW; }
<YYINITIAL, IN_INTERPOLATION>  "do"                       { return DO_KW; }
<YYINITIAL, IN_INTERPOLATION>  "else"                     { return ELSE_KW; }
<YYINITIAL, IN_INTERPOLATION>  "enum"                     { return ENUM_KW; }
<YYINITIAL, IN_INTERPOLATION>  "fn"                       { return FN_KW; }
<YYINITIAL, IN_INTERPOLATION>  "task"                     { return TASK_KW; }
<YYINITIAL, IN_INTERPOLATION>  "for"                      { return FOR_KW; }
<YYINITIAL, IN_INTERPOLATION>  "if"                       { return IF_KW; }
<YYINITIAL, IN_INTERPOLATION>  "in"                       { return IN_KW; }
<YYINITIAL, IN_INTERPOLATION>  "is"                       { return IS_KW; }
<YYINITIAL, IN_INTERPOLATION>  "limit"                    { return LIMIT_KW; }
<YYINITIAL, IN_INTERPOLATION>  "native"                   { return NATIVE_KW; }
<YYINITIAL, IN_INTERPOLATION>  "null"                     { return NULL_KW; }
<YYINITIAL, IN_INTERPOLATION>  "private"                  { return PRIVATE_KW; }
<YYINITIAL, IN_INTERPOLATION>  "return"                   { return RETURN_KW; }
<YYINITIAL, IN_INTERPOLATION>  "sampling"                 { return SAMPLING_KW; }
<YYINITIAL, IN_INTERPOLATION>  "skip"                     { return SKIP_KW; }
<YYINITIAL, IN_INTERPOLATION>  "static"                   { return STATIC_KW; }
<YYINITIAL, IN_INTERPOLATION>  "this"                     { return THIS_KW; }
<YYINITIAL, IN_INTERPOLATION>  "throw"                    { return THROW_KW; }
<YYINITIAL, IN_INTERPOLATION>  "try"                      { return TRY_KW; }
<YYINITIAL, IN_INTERPOLATION>  "type"                     { return TYPE_KW; }
<YYINITIAL, IN_INTERPOLATION>  "typeof"                   { return TYPE_OF_KW; }
<YYINITIAL, IN_INTERPOLATION>  "use"                      { return USE_KW; }
<YYINITIAL, IN_INTERPOLATION>  "var"                      { return VAR_KW; }
<YYINITIAL, IN_INTERPOLATION>  "while"                    { return WHILE_KW; }
<YYINITIAL, IN_INTERPOLATION>  "without"                  { return WITHOUT_KW; }
<YYINITIAL, IN_INTERPOLATION>  "true"                     { return TRUE_KW; }
<YYINITIAL, IN_INTERPOLATION>  "false"                    { return FALSE_KW; }
<YYINITIAL, IN_INTERPOLATION>  "extends"                  { return EXTENDS_KW; }

// terminals
<YYINITIAL, IN_INTERPOLATION>  "("                        { return LPAREN; }
<YYINITIAL, IN_INTERPOLATION>  ")"                        { return RPAREN; }
<YYINITIAL, IN_INTERPOLATION>  "{"                        { return LCURLY; }
<YYINITIAL, IN_INTERPOLATION>  "}"                        { return RCURLY; }
<YYINITIAL, IN_INTERPOLATION>  "["                        { return LSQUARE; }
<YYINITIAL, IN_INTERPOLATION>  "]"                        { return RSQUARE; }
<YYINITIAL, IN_INTERPOLATION>  ","                        { return COMMA; }
<YYINITIAL, IN_INTERPOLATION>  ".."                       { return DOT_DOT; }
<YYINITIAL, IN_INTERPOLATION>  "."                        { return DOT; }
<YYINITIAL, IN_INTERPOLATION>  "^"                        { return CARET; }
<YYINITIAL, IN_INTERPOLATION>  "&&"                       { return AMP_AMP; }
<YYINITIAL, IN_INTERPOLATION>  "&"                        { return AMP; }
<YYINITIAL, IN_INTERPOLATION>  ">="                       { return GT_EQ; }
<YYINITIAL, IN_INTERPOLATION>  ">"                        { return GT; }
<YYINITIAL, IN_INTERPOLATION>  "<="                       { return LT_EQ; }
<YYINITIAL, IN_INTERPOLATION>  "<"                        { return LT; }
<YYINITIAL, IN_INTERPOLATION>  "||"                       { return BAR_BAR; }
<YYINITIAL, IN_INTERPOLATION>  "|"                        { return BAR; }
<YYINITIAL, IN_INTERPOLATION>  "->"                       { return ARROW; }
<YYINITIAL, IN_INTERPOLATION>  "@"                        { return AT; }
<YYINITIAL, IN_INTERPOLATION>  "'"                        { return SQUOTE; }
<YYINITIAL, IN_INTERPOLATION>  "::"                       { return COLON_COLON; }
<YYINITIAL, IN_INTERPOLATION>  ":"                        { return COLON; }
<YYINITIAL, IN_INTERPOLATION>  ";"                        { return SEMI; }
<YYINITIAL, IN_INTERPOLATION>  "$"                        { return DOLLAR; }
<YYINITIAL, IN_INTERPOLATION>  "/="                       { return SLASH_EQ; }
<YYINITIAL, IN_INTERPOLATION>  "/"                        { return SLASH; }
<YYINITIAL, IN_INTERPOLATION>  "--"                       { return MINUS_MINUS; }
<YYINITIAL, IN_INTERPOLATION>  "-="                       { return MINUS_EQ; }
<YYINITIAL, IN_INTERPOLATION>  "-"                        { return MINUS; }
<YYINITIAL, IN_INTERPOLATION>  "++"                       { return PLUS_PLUS; }
<YYINITIAL, IN_INTERPOLATION>  "+="                       { return PLUS_EQ; }
<YYINITIAL, IN_INTERPOLATION>  "+"                        { return PLUS; }
<YYINITIAL, IN_INTERPOLATION>  "*="                       { return STAR_EQ; }
<YYINITIAL, IN_INTERPOLATION>  "*"                        { return STAR; }
<YYINITIAL, IN_INTERPOLATION>  "%="                       { return PERCENT_EQ; }
<YYINITIAL, IN_INTERPOLATION>  "%"                        { return PERCENT; }
<YYINITIAL, IN_INTERPOLATION>  "=="                       { return EQ_EQ; }
<YYINITIAL, IN_INTERPOLATION>  "="                        { return EQ; }
<YYINITIAL, IN_INTERPOLATION>  "!="                       { return NOT_EQ; }
<YYINITIAL, IN_INTERPOLATION>  "!!"                       { return NOT_NOT; }
<YYINITIAL, IN_INTERPOLATION>  "!"                        { return NOT; }
<YYINITIAL, IN_INTERPOLATION>  "??"                       { return QUESTION_QUESTION; }
<YYINITIAL, IN_INTERPOLATION>  "?="                       { return QUESTION_EQ; }
<YYINITIAL, IN_INTERPOLATION>  "?"                        { return QUESTION; }

// non-terminals
<YYINITIAL, IN_INTERPOLATION>  {CHAR_LIT}                 { return STRING; }
<YYINITIAL, IN_INTERPOLATION>  {IDENTIFIER}               { return IDENTIFIER; }
<YYINITIAL, IN_INTERPOLATION>  {WHITE_SPACE}              { return WHITE_SPACE; }
<YYINITIAL, IN_INTERPOLATION>  {LINE_COMMENT}             { return LINE_COMMENT; }
<YYINITIAL, IN_INTERPOLATION>  {NUMBER}                   { return NUMBER; }

<IN_TEMPLATE>                  \"                         { popState(); return DQUOTE; }
<IN_TEMPLATE>                  "${"                       { pushState(IN_INTERPOLATION); return ENTER_INTERPOLATION; }
<IN_TEMPLATE>                  ([^\\\"\n\$] | (\\.))+     { return RAW_STRING; }
<IN_TEMPLATE>                   \n                        { return WHITE_SPACE; }

// If the character sequence does not match any of the above rules, we return BAD_CHARACTER which indicates that
// there is an error in the character sequence. This is used to highlight errors.
<YYINITIAL, IN_TEMPLATE, IN_INTERPOLATION, IN_COMMENT> [^] { return BAD_CHARACTER; }
